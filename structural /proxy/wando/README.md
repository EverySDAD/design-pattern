# proxy pattern

> 정의  

일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다.  
프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다.  

또한, 이 패턴에는 여러가지 종류가 있다.  
- 원격 프록시
    - 원격 객체에 대한 접근 가능
- 가상 프록시
    - 객체의 생성 비용이 많이 들어, 미리 생성하기 부담될 때 접근 및 생성시점 등을 제어
- 보호 프록시
    - 객체에 따른 접근 권한을 줘야할때
- 방화벽 프록시
    - 네트워크 자원에 대한 접근을 제어해 접근불가한 클라이언트 들로부터 보호
- 스마트 레퍼런스 프록시
    - 주 객체가 참조될때마다 추가 행동 제공
    - ex. 참조에 대한 선,후 작업 등)
- 캐싱 프록시
    - 비용이 많이 드는 작업을 임시로 저장
    - 추후 여러 클라들에 저장된 결과를 실제 작업처리 대신 보여줌으로써 자원을 절약
- 동기화 프록시
    - 여러 쓰레드에서 주 객체에 접근하는 경우에 안전하게 작업 처리
    - 주로 분산 환경에서 일련의 객체에 대한 동기화 된 접근을 제어해주는 자바 등에서 쓰임.)
- 복잡도 프록시
    - 복잡한 클래스들의 집합에 대한 접근을 제어하고, 복잡도를 숨김
- 지연 복사 프록시
    - 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어
    - '변형된 가상 프록시'라고 함

UML등 자세한 내용은 아래 링크로 들어가시길

출처 : [갓키피디아-프록시패턴][wiki-proxy-pattern]

[wiki-proxy-pattern]: https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4 "위키피디아로 고고씽"

<hr/>

> 내 생각

프록시 패턴의 종류가 많긴 하지만,  
사실 다들 프록시 패턴의 틀은 동일하다.

프록시 패턴의 정의만 알고 있으면, 해당하는 종류들은 네이밍의 의미를 알고 구현가능 할거같다.

<hr />

> golang 으로 구현

프로시 패턴 구현 시나리오 (전략 패턴에서 구현했던 보디가드의 역할을 프록시 패턴으로 변경할 예정)
```plaintext
1. 보디가드가 막기 전에 자신은 완도패밀리의 보디가드라고 인사 하는것을 추가
2. 보디가드에 바로 추가하면 OCP에 위배 (기존소스를 건드리게 되므로)
3. 프륵시 패턴중 원격 프록시 + 스마트 레퍼런스 프록시 사용
```

<hr/>

> 이견 or 의견

```
이견 이나 의견 혹은 잘못된 정보가 있다면 언제든 박살내주시기 바랍니다. :)
```
